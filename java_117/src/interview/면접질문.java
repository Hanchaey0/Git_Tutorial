//1.상수
/*
 * 상수 : 프로그램이 실행되는 동안, 값이 변하지 않는 수 또는 변경 불가능한 수
 * 			 주로 대문자 사용 (변수는 소문자)
 * 			 만약 값을 변경해야 할 경우, 상수를 선언한 부분의 값만 변경하면 된다. (편리성)
 * 
 * 	문법 : final 자료형 변수명;		예) final double PI = 3.14;
 * 			1) 변수(상수) : 변수에 값 대입불가 - 변경불가
 * 			2) 메서드에서도 사용이 가능하다. 재정의 불가
 * 			3) 클래스에도 사용이 가능하다. - 상속불가
 * 			4) 메소드와 클래스에도 모두 사용 가능하다.
 *  
 */


//	----------------------------------------
//	2. package ch02;
//
//	public class _13_WhileEx {
//		public static void main(String[] args) {
/* **********
 * * 구구단 출력 *
 * **********
 * === 2단 ===
 * **********
 * 2 * 1 = 2
 * 2 * 2 = 4
 * 
 * ~
 * 2 * 8 = 16
 * 2 * 9 = 18
 * ==========
 * === 3단 ===
 * 3 * 1 = 2
 * 3 * 2 = 6
 * 
 * ~
 * 3 * 8 = 24
 * 3 * 9 = 27
 * === 9단 ===
 * 9 * 1 = 9
 * 9 * 2 = 18
 * 
 * ~
 * 9 * 8 = 72
 * 9 * 9 = 81
 * ==========
 * 		 
 */

//1. 초기값
//			int dan = 2;
//			System.out.println("***********");
//			System.out.println("* 구구단 출력 *");
//			System.out.println("***********");


//2. 조건식
//			while(dan<10) {
//
//				System.out.println("=== "+dan+ "단 ===");
//
//
//				//1-1.초기값
//				int i = 1;
//				//1-2.조건식
//				while(i<10) {
//					System.out.println(dan +"*"+ i +"=" +(dan*i));
//					// 구구단 출력
//					//1-3.증감식
//					i++;
//				}
//				dan++;
//			}
//			//3. 증감식
//			int i=1; 
//			System.out.println("========");
//		}
//	}
/*p.153
 * 생성자를 클래스를 new연산자로 생성할 때만 호출된다.
 * 생성자 이름은 클래스명과 같고, 반환값이 없다.
 * 기본생성자는 컴파일할 때 컴파일러가 자동으로 기본생성자를 만들어준다. (단 생성자가 하나도 없는 경우)
 * 하지만 매개변수가 생성자가 존재하면 컴파일러가 기본생성자를 자동으로 만들어주지 않는다.
 */
//디폴트 생성자
//3. 생성자 오버로드 : 메서드나 생산자의 매개변수 갯수가 다르거나 타입이 다른 경우를 말하며, 
//		리턴 타입은 같아도 무관하다.
//	public _04_Worker() {}
//	//매개변수 생성자 : 1.Main에서 값 전달 ->2. 매개변수로 전달->3.멤버변수로 전달
//	public _04_Worker(int sabun, String name, int salary) {
//		this.sabun = sabun;
//		this.name = name;
//		this.salary = salary;
//	}
//멤버 메서드 - 기능
//	public void setSabun(int sabun) {
//		this.sabun = sabun;
//	}
//	public int getSabun() {
//		return sabun;
//	}
//	public void setName(String name) {
//		this.name = name;
//	}
//	public String getName() {
//		return name;
//
//		오버로드(재정의): 부모의 메서드를 재정의

/*4. 접근제어자
	private -> default -> protected -> public

	/*5. 객체 지향 의미
	JVM(Java Virtual Machine: 자바가상머신) - 자바 프로그램 실행 환경을 만들어주는 소프트웨어
		JRE가 설치되면 JVM이 사용가능
		자바코드를 컴파일(.java -> .class)하면 자바가상머신 환경에서 실행
	OS에 영향을 받지 않는다(컴파일한 상태이면 JVM에의해 OS에 상관없이 실행가능하다.)
	메서드를 재사용하므로 유지보수가 쉽고 확장성이 좋다.
	클래스 의미, 인스턴스생성 : 클래스명 참조변수 = new 생성자;,
	참조변수:인스턴스 생성시의 주소값을 저장, 멤버변수, 멤버메서드 접근 문법	


	/*[면접]
	/ 6.
	/ static 변수 = 정적변수 = 공유변수 = 클래스변수
	/ static 변수 :
	/ -프로그램이 실행되어 메모리에 올라갔을 때 딱 한번 데이터영역 메모리 공간에 할당된다.
	/ -객체를 생성하지 않고, 바로 클래스명으로 접근가능하다.
	/ 인스턴스마다 생성되는 변수가 아니라, 클래스에 속해 한번만 생성되는 변수이고, 여러 인스턴스가 공유하기 때문이다.
	/ 인스턴스가 생성되지 않아도 사용할 수 있기 때문에 클래스명.static변수, 클래스명.static메서드 사용가능
	/ 
	/ -static 변수나 메서드는 static 메서드에서 호출가능
	/ (정적메서드에서 인스턴스 변수나 메서드를 호출시 컴파일 오류가 난다.)
	/ static 메서드는 프로그램 실행시 자동으로 메모리에 올라가나, 일반메서드는 객체를 생성해야 메모리에 올라간다.
	/ 
 /*
 * 7. 상속
 * 
 */
/*면접
 * 상속 : 자식클래스 extends부모클래스 {.....}
 * 
 */
/*8. 
 * 추상이란?
 * - 여러가지 사물이나 개념으로부터 공통이 되는 특성을 파악하는 것을 말한다.
 * 
 * [면접]
 * 1. 추상클래스 => 작업명세서 : 정의된 추상메서드
 * - 하나 이상의 추상메서드를 가지고 있는 클래스를 의미한다.
 * - abstract 키워드를 이용하여 구현되지 않는 추상메서드를 기술할 수 있다.
 * - 자식클래스에게 구현을 위임하고자 할 때 사용되며, 프로그램의 확장성을 취해 많이 사용하는 설계방법이다.
 * - 추상클래스는 일반메서드, 추상메서드 모두 올 수 있다.
 * - 전제조건은 반드시 상속을 해야 한다.
 * - 다형성 적용 가능하다.
 * 
 * - 문법 : public abstract class 클래스명 {
 *             public abstract 반환형 메서드명();  // 추상메서드
 *       }
 * 
 * 2. 추상메서드
 * - 하위클래스가 어떤 클래스냐에 따라 구현코드가 달라지며, 하위클래스에 구현을 위임하는 것이다.
 * - 미완성되어있는 메서드이며, 몸체가 없는 메서드로서 항상 세미콜론(;)으로 종료되어야 한다.
 * 
 *  3. 추상클래스의 상속
 *  - 추상클래스를 상속받은 자식클래스는 추상메서드를 반드시 재정의(Override) 해야 하며,
 *    재정의하지 않으면 컴파일 오류가 발생한다.
 *  - 자식클래스에게 강제성과 통일성을 줄 수 있다.(협업시 작업명세서)  
 *       
 * 4. 추상클래스의 객체 생성
 * - 추상클래스는 객체를 생성할 수 없으며(추상 메서드 때문), 상속 계층에서
 *   추상적인 개념을 나타내기 위한 용도로 사용한다.
 * - 상속을 통하여 자식클래스에서 추상메서드를 구현하고, 자식클래스 객체를 생성하여 메서드를 접근할 수 있다.  
 * 
 */


/* 9. 시험
 * 템플릿 메서드 : 
 * - 메서드 실행순서와 시나리오를 정의하는 것이다.
 * - 로직 흐름이 이미 정해져 있는 프레임워크에서 많이 사용하는 구현 방법이다.
 * - final로 선언한 이유는 모든 하위클래스가 공통으로 사용하고, 코드를 변경하면 안되기 때문에 final로 선언함
 * final 메서드명 : 상속받은 하위 클래스가 부모 메서드를 재정의 할 수 없다.  
 * 
 * final  p305
 * 1) 변수(상수) : 변수에 값 대입불가
 * 2) 메서드 : 재정의 불가
 * 3) 클래스 : 상속 불가
 */


/*	10.
 * [면접] 추상클래스 vs 인터페이스
 *       인터페이스 설명
 *       
 *  인터페이스 
 *  - 기능정의서(표준 작업명세서)이다. - 강제성과 통일성
 *  - 설계(선언)와 구현을 분리시키는 것을 가능하게 한다.
 *    (설계 : 인터페이스, 구현 : 자식클래스)
 *  - 객체생성 불가능하며, 객체 Type으로 가능하다.(다형성 적용)
 *  - 인터페이스의 멤버는 상수(static final 생략 가능), 추상메서드(abstract 생략 가능)만 올수 있다.
 *  - 단 static 메서드, 디폴트 메서드, private 메서드는 예외(JDK 1.8부터)
 *  - 인터페이스를 implements(=구현)할 자식클래스에서 추상메서드를 재정의한다.
 *  
 *  1. 인터페이스 작성
 *  interface 인터페이스명 {
 *     // 상수
 *     public static final 데이터타입 대문자상수명 = 값;
 *      // 추상메서드
 *      public 반환형 추상메서드(매개변수1,...);  // body없다
 *  }
 *  
 *  2. 인터페이스 구현
 *  class 클래스명 implements 인터페이스명{
 *     @Override
 *      public 반환형 추상메서드(매개변수1,...) {
 *          // 인터페이스에 정의된 추상메서드를 구현해야 한다.
 *       }
 *  }
 * 
 * 3. 인터페이스는 다중 상속 가능    cf) 클래스는 단일 상속만 가능
 * interface 인터페이스명  extends  인터페이스명1, .. 인터페이스명n {
 * 
 * }
 * 
 * class 클래스명  extends  클래스명1, .. 클래스명n {  //NG - 클래스는 단일 상속만 가능
 * }
 * 
 * 4. 상속과 구현을 동시
 * class 클래스명 extends 부모클래스 implements 인터페이스명1, .. 인터페이스명n {
 * 
 * }
 * 
 * 자바 8부터 디폴트 메서드, 정적 메서드를 구현할 수 있다.
		     자바 9부터 private 메서드를 구현할 수 있다.
 */

/* 11.
 * 팩토리 메서드(factory method)
 * - 객체를 생성하는 정적 팩토리메서드이다.
 *   이것은 디자인 패턴의 하나로서 객체를 만드는 부분을 자식클래스에게 위임하는 패턴이다.
 *   즉 new 연산자를 호출하여 객체를 생성하는 코드를 자식클래스에게 위임하는 패턴이다.
 *   사용하는 이유는 하나의 클래스가 변경되었을 경우에 다른 클래스의 변경을 최소화하기 위함이다.
 *   
 *   팩토리 메서드 이름으로 많이 사용되는 것은 getInstance()이다.
 *   인터페이스에서 팩토리 메서드를 제공할 때 정적메서드를 사용하게 된다.
 *   static이므로 클래스명.정적메서드로 접근
 * 
 */



/*12
 * [ArrayList]
 * 
 *         Collection 인터페이스
 * - List 인터페이스 : 클래스 종류는 ArrayList, Vector, LinkedList
 * - Set 인터페이스 : 클래스종류는 HashSet, TreeSet
 * - Map 인터페이스 : 클래스종류는 HashMap, HashTable, TreeMap
 * 
 *  <면접>
 *  1. 특징
 *  List 인터페이스 : 순서가 있는 자료관리, 중복허용한다.
 *                 index를 사용하여 요소에 접근한다.
 *                 리스트에 들어있는 요소들의 인덱스는 0부터 시작한다.
 *                 클래스종류는 ArrayList, Vector, LinkedList
 *                 
 *  Set 인터페이스 : 순서가 없는 자료관리, 중복허용 않는다.
 *                클래스종류는 HashSet, TreeSet
 * 
 * 
 * 
 * 2. 선언
 *		wrapper클래스들이 <>에 들어간다. Integer, String... 
 * 클래스명<데이터타입클래스> 참조변수 = new 클래스명<데이터타입클래스>();
 * ArrayList<String> list = new ArrayList<String>();
 *
 *
 * 다형성 적용
 * List<String> list = new ArrayList<String>();
 * List인터페이스
 * 
 * String타입이 오면 오른쪽에도 마찬가지로 String타입을 적는다.
 * ArrayList라는 바구니 안에 문자열만 순서대로 집어넣겠다. String. 
 * 정수만 넣겠다. Integer. (클래스기때문에 int안됨.)
 * p.375
 * 동일한 자료형에 대량의 데이터를 넣을 때 사용하는 것 = 배열.
 * Array도 마찬가지로 배열이다.
 * Array있는데 왜 ArrayList를 쓰는가.
 * 배열은 갯수가 정해져있다 동일한 자료형의 대량의 데이터를 정해진 갯수만큼만(선언한 갯수만큼)쓰는 것.
 * ArrayList : 갯수는 상관 없으나, <동일한 자료형>만 사용.
 * 
 * 3. 특징 : 데이터 순서가  있다. 중복 허용 된다.
 * 4. 추가 : list.add(값);	//앞에서부터 순서대로 추가
 * 		   list.add(추가할 위치 index,값); //지정한 인덱스에 값을 추가, 그 뒤의 값은 밀려난다.
 * 5. 값 가져오기 : list.get(가져올 index);  //list.size()만큼 반복
 * 
 * 6. 교체 : list.set(교체할 위치 index, 값); //지정한 인덱스의 값을 변경 .. 그 뒤값은 그대로이다.
 * 7. 삭제 : list.remove(삭제할 위치 index, 값);
 * 8. 검색 : list.indexOf(검색할 값); 	// 중요
 * 		리스트에서 검색할 값과 똑같은 값을 갖는 첫번째 데이터를 찾아서 그 위치의 인덱스를 리턴한다.
 * 		검색할 값과 일치한 데이터가 없으면 -1을 리턴한다.
 * 
 * 9. 전체 삭제 : list.clear();
 * 10. 반복자 : Iterator<E> interator : while(hasNext()) {next()}
 * 
 * 
 *//*
 * [면접] p439
 * 해싱(hashing) : 키를 이용해서 해시테이블로부터 데이터를 가져오는 과정
 * 
 * HashMap
 * 1) 특징
 * - 데이터의 순서를 보장하지 않는다.
 * - key와 value 쌍으로 저장한다.
 * - key는 중복되면 안된다.
 * - key를 이용해서 value를 가져올 수 있다.
 * - List 계열과 달리 index가 없다.
 * - Map이라는 인터페이를 구현한 클래스이다.
 * 
 * 2) 선언
 * - HashMap<Key 타입, value 타입> map = new HashMap<Key 타입, value 타입>();
 * - Map<Key 타입, value 타입> map = new HashMap<Key 타입, value 타입>(); // 다형성 적용
 * 
 * 3) 메서드
 * - 데이터 추가 : put(key, value);
 * - 데이터 가져오기 : get(key)
 * - 데이터 삭제 : remove(key)
 * - 데이터가 비어있는지 여부 : isEmpty()
 * - 해당 키가 있는지 여부 : containsKey(key)
 * - 해당 값이 있는지 여부 : containsValue(value)
 * - 해당 갯수 : size()
 */


/*13
 * 	
 * [면접]
 * 제네릭 : 여러 참조 자료형이 쓰일수 있는 곳에 특정한 자료형을 지정하지 않고
 *        클래스나 메서드를 지정한 후 사용하는 시점(제네릭 클래스의 인스턴스 생성시점)에
 *        어떤 자료형을 사용할 것인지 지정하는 방식
 *        (단 제네릭클래스가 static이면 예외) 
 *        T : Type parameter
 *        E : element
 *        K : Key
 *        V : value
 *        
 *  - 제네릭으로 구현하면 형변환을 하지 않아도 된다.(매개변수의 다형성, 다운캐스팅 안해도 된다.)
 *  => 제네릭 클래스를 사용하면 컴파일러는 일단 대입된 자료형이 잘 쓰였는지 검증한다.
 *     class 파일을 생성할 때 T를 사용한 곳에 지정된 자료형에 따라 컴파일하므로     
 */

/*14.예외처리
 * 
 * [면접]
 * 예외 처리 목적 : 정상종료
 * 
 * try {
 * 
 * }catch(처리할 예외타입 e){
 * 	//try 블록안에서 예외가 발생했을 때 예외를 처리하는 부분
 * 
 * }finally{
 *  //형상 수행되는 부분(예외가 발생하지 않더라도),
 *  //주로 자원해제를 위한 close() 문장이 온다.
 *  }
 */
	/*
     * 1. 강제예외발생 : throw new Exception(message);
     * 2. 상위 메서드에게 예외 던지기
     *    throws Exception
     * 3. 예외 처리
     *    catch(던진 Exception e){e.getMaessage()}로 받는다.
     * 
     * 기본 예외처리를 하는 exception클래스 블록이 여러예외처리 중 가장 아래에 자리하는것이 좋다.
     * catch문이 여러개일때,(다중 catch) 부모 exception이 제일 아래오도록 하는 것이 좋다.
     */

/*15 Thread 생성과 실행
	* (1) Thread 클래스를 상속하기
	* 1. Thread 클래스를 상속받아서 클래스를 작성한다.
	* 2. 추상메서드 run()메서드를 재정의(Override)한다
	* 3. main()메서드에서 Thread객체를 생성한다.
	* 4. start()메서드를 호출해서 스레드를 실행한다.
	* 5. run()메서드가 실행된다.
	* 
	* (2) 2)Runnable인터페이스를 구현하기
	* 1. Runnable 인터페이스를 implements 받아 클래스를 작성한다.
	* 2. 추상메서드 run()메서드를 재정의(Override)한다
	* 3. main()메서드에서 Thread객체를 생성하고, implements 받은 클래스 객체를 매개변수로 전달한다.
	* 4. start()메서드를 호출해서 스레드를 실행한다.
	* 5. run()메서드가 실행된다.
	* 
	*/

/*16
    * [synchronized] - 동기화 .. 문서출력
    *   예)A,B,C 출력순서는 달라질수는 있으나(시분할), 문서는 섞이면 안된다.
    *   
    * 동기화란 공유된 자원중에서 동시에 사용하면 안되는 자원에 대해 잠금(lock)을 수행하여 보호하는 도구이다.
    * 즉 메서드를 호출할 때 객체에 잠금을 하고, 메서드 수행이 끝나면 잠금을 해제한다.
    * 이 때 Vector라는 자료구조가 사용되고, 메서드가 호출될 때 마다 잠금과 해제가 일어나므로 ArrayList보다 수행속도가 느리다.
    * 
    * [임계 영역(critical section)]
    * - 한 사용자가 자원을 사용하고 있으면, 다른 사용자는 사용이 끝날때까지 기다려야 한다.
    *   이러한 영역을 임계영역이라고 한다.
    *   
    * - 동기화 메서드를 만들기 위해서는   synchronized 키워드를 메서드 선언에 붙이면 된다.
    * - synchronized 키워드를 사용하면, 어떠한 순간에는 하나의 스레드만이 임계영역 안에서 실행하는 것이 보장된다.
    * - synchronized 키워드가 붙어있으면, 하나의 스레드가 공뮤메서드를 실행하는 동안에, 다른 스레드는 공유메서드를 실행할 수 없다.
    * 
    * - wait() 메서드는 어떤 일이 일어나기를 기다릴 때 사용하는 메서드이다.
    * - notify() 메서드는 반대로 어떤 일이 일어났을 때 이를 알려주는 메서드이다.
    * 
    * <임계 영역(critical section)의 동기화>
    * - critical section이 문제를 일으키지 않으려면 그 부분이 실행되는 동안
    *   다른 스레드가 공유 데이터를 사용할 수 없도록 만드는 것을 말한다.
    */
